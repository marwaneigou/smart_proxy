import os
import re
import tempfile
from mitmproxy import ctx
from mitmproxy import http  # Needed for blocking responses

MALWARE_PATTERNS = [
    b'MZ',  # PE executable
    b'PK\x03\x04',  # ZIP
    b'%PDF',  # PDF
    b'VIRUS',  # Example string
]
SUSPICIOUS_EXTENSIONS = ['.exe', '.zip', '.pdf', '.scr', '.bat', '.dll']

try:
    import pyclamd
    CLAMD_AVAILABLE = True
    print("ClamAV support enabled.")
except ImportError:
    CLAMD_AVAILABLE = False
    print("ClamAV support disabled. Install pyclamd to enable.")

def scan_file(filepath):
    # Try ClamAV first
    if CLAMD_AVAILABLE:
        try:
            cd = pyclamd.ClamdAgnostic()
            if cd.ping():
                result = cd.scan_file(filepath)
                if result:
                    return True, str(result)
        except Exception as e:
            ctx.log.warn(f"[ClamAV Error] {e}")
    # Fallback: simple static scan
    with open(filepath, 'rb') as f:
        data = f.read(4096)
        for pattern in MALWARE_PATTERNS:
            if pattern in data:
                return True, f"Pattern {pattern}"
    return False, None

def is_download(flow):
    cd = flow.response.headers.get('content-disposition', '').lower()
    if 'attachment' in cd:
        return True
    url = flow.request.pretty_url.lower()
    for ext in SUSPICIOUS_EXTENSIONS:
        if url.endswith(ext):
            return True
    return False

import yaml
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False

# Import dashboard if available
try:
    import dashboard
    DASHBOARD_AVAILABLE = True
except ImportError:
    DASHBOARD_AVAILABLE = False

class MalwareScanner:
    def __init__(self, report, config=None):
        self.report = report
        self.config = config or {}
        # Load YARA rules if enabled
        self.yara_rules = None
        if self.config.get('malware', {}).get('enable_yara', False) and YARA_AVAILABLE:
            try:
                self.yara_rules = yara.compile(filepath=self.config['malware']['yara_rules_path'])
            except Exception as e:
                ctx.log.warn(f"[YARA Error] {e}")

    def response(self, flow):
        if is_download(flow):
            self.report['downloads_scanned'] += 1
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                tmp.write(flow.response.content)
                tmp_path = tmp.name
            try:
                # Async scan structure (placeholder, not true async)
                found, reason = scan_file(tmp_path)
                # YARA scan (if enabled)
                if self.yara_rules:
                    try:
                        matches = self.yara_rules.match(tmp_path)
                        if matches:
                            found = True
                            reason = f"YARA match: {matches}"
                    except Exception as e:
                        ctx.log.warn(f"[YARA Scan Error] {e}")
                if found:
                    ctx.log.warn(f"[Malware Detected] {flow.request.pretty_url} Reason: {reason}")
                    self.report['malware_found'].append((flow.request.pretty_url, reason))
                    # Replace with proper block page
                    flow.response = http.Response.make(
                        403,  # HTTP status code
                        b"<html><body><h1>Malware Blocked</h1><p>This download contains malware and has been blocked.</p><p>Reason: " + 
                        str(reason).encode('utf-8') + b"</p></body></html>",
                        {"Content-Type": "text/html"}
                    )
                    if DASHBOARD_AVAILABLE:
                        dashboard.add_log('ERROR', f"[Malware Detected] {flow.request.pretty_url} Reason: {reason}")
                else:
                    ctx.log.info(f"[Download Clean] {flow.request.pretty_url}")
                    if DASHBOARD_AVAILABLE:
                        dashboard.add_log('INFO', f"[Download Clean] {flow.request.pretty_url}")
                # TODO: Save scan results to persistent log if enabled in config
            finally:
                os.remove(tmp_path)
            # TODO: Async scan (real async/threaded), threat intelligence lookup, whitelist/blacklist

def load(l):
    if not hasattr(ctx, 'report'):
        ctx.report = {'phishing_urls': [], 'suspicious_js': [], 'unexpected_redirects': [], 'malware_found': [], 'downloads_scanned': 0}
    l.addons.add(MalwareScanner(ctx.report))
