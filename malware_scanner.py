import os
import re
import tempfile
import time
from mitmproxy import ctx
from mitmproxy import http  # Needed for blocking responses

MALWARE_PATTERNS = [
    b'MZ',  # PE executable
    b'PK\x03\x04',  # ZIP
    b'%PDF',  # PDF
    b'VIRUS',  # Example string
    b'EICAR-STANDARD-ANTIVIRUS-TEST-FILE',  # EICAR test pattern
    b'X5O!P%@AP',  # Alternative EICAR start
    b'\x50\x45\x00\x00',  # PE header
    b'TVqQAAMAAAA',  # Base64 encoded MZ header
]
SUSPICIOUS_EXTENSIONS = [
    '.exe', '.zip', '.pdf', '.scr', '.bat', '.dll', '.com', '.dmg', '.jar', 
    '.rar', '.iso', '.7z', '.msi', '.vbs', '.js', '.ps1', '.sh', '.py', 
    '.jsp', '.php', '.apk', '.xls', '.xlsx', '.doc', '.docx', '.ppt', '.pptx'
]

try:
    import pyclamd
    CLAMD_AVAILABLE = True
    print("ClamAV support enabled.")
except ImportError:
    CLAMD_AVAILABLE = False
    print("ClamAV support disabled. Install pyclamd to enable.")

def scan_file(filepath):
    # OPTIMIZATION: First do a quick pattern match as it's faster
    with open(filepath, 'rb') as f:
        data = f.read(4096)  # Only read first 4KB for quick scan
        for pattern in MALWARE_PATTERNS:
            if pattern in data:
                return True, f"Pattern {pattern}"
    
    # If quick scan passes, try ClamAV with a timeout
    if CLAMD_AVAILABLE:
        try:
            import threading
            import queue
            
            result_queue = queue.Queue()
            
            def clamd_scan():
                try:
                    cd = pyclamd.ClamdAgnostic()
                    if cd.ping():
                        result = cd.scan_file(filepath)
                        if result:
                            result_queue.put((True, str(result)))
                        else:
                            result_queue.put((False, None))
                except Exception as e:
                    ctx.log.warn(f"[ClamAV Error] {e}")
                    result_queue.put((False, None))
            
            # Start ClamAV scan in a thread with timeout
            scan_thread = threading.Thread(target=clamd_scan)
            scan_thread.daemon = True
            scan_thread.start()
            
            # Wait for result with timeout (2 seconds max)
            try:
                return result_queue.get(timeout=2.0)
            except queue.Empty:
                ctx.log.warn("[ClamAV Timeout] Scan took too long, skipping")
        except Exception as e:
            ctx.log.warn(f"[ClamAV Thread Error] {e}")
    
    # If we reach here, file passed all scans
    return False, None

def is_download(flow):
    """Check if a flow contains a downloadable file
    Returns a tuple (is_download, reason) where reason explains why it was detected
    """
    # Skip HTML content - handle separately through traffic analyzer
    content_type = flow.response.headers.get('content-type', '').lower()
    if 'text/html' in content_type:
        return False, None
        
    # Check content-disposition header
    cd = flow.response.headers.get('content-disposition', '').lower()
    if 'attachment' in cd:
        return True, "Content-Disposition: attachment"
    if 'filename' in cd:
        return True, "Content-Disposition: filename"
        
    # Check content-type for binary/downloadable types
    downloadable_types = [
        'application/', 'binary/', 'octet-stream',
        'executable', 'zip', 'archive', 'java-archive',
        'msword', 'excel', 'powerpoint', 'pdf'
    ]
    if any(dtype in content_type for dtype in downloadable_types):
        return True, f"Content-Type: {content_type}"
        
    # Check URL for file extensions
    url = flow.request.pretty_url.lower()
    
    # Check for suspicious extensions
    for ext in SUSPICIOUS_EXTENSIONS:
        if url.endswith(ext):
            return True, f"Suspicious extension: {ext}"
    
    # Check for any file extension
    if '.' in url.split('/')[-1]:
        file_part = url.split('/')[-1]
        # If there's a period and no query string, likely a file
        if '?' not in file_part:
            file_ext = '.' + file_part.split('.')[-1]
            # Don't treat HTML files as downloads
            if file_ext.lower() == '.html' or file_ext.lower() == '.htm':
                return False, None
            return True, f"File extension: {file_ext}"
        # If there's a query string, check if before the query
        else:
            name_part = file_part.split('?')[0]
            if '.' in name_part:
                file_ext = '.' + name_part.split('.')[-1]
                # Don't treat HTML files as downloads
                if file_ext.lower() == '.html' or file_ext.lower() == '.htm':
                    return False, None
                return True, f"File extension: {file_ext}"
                
    # Check for large binary responses (might be downloads)
    if len(flow.response.content) > 25000:  # 25KB threshold
        # Check first few bytes for binary signatures
        data = flow.response.content[:32]
        binary_signatures = [b'\x00\x00\x00\x00', b'\xFF\xD8\xFF', b'\x89PNG', b'GIF8']
        if any(sig in data for sig in binary_signatures):
            return True, "Binary content signature detected"
            
    return False, None

import yaml
try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False

# Import dashboard if available
try:
    import dashboard
    DASHBOARD_AVAILABLE = True
except ImportError:
    DASHBOARD_AVAILABLE = False

class MalwareScanner:
    def __init__(self, report, config=None):
        self.report = report
        self.config = config or {}
        # Track whitelist file changes
        self.whitelist_last_modified = 0
        self.whitelist_path = os.path.join(os.path.dirname(__file__), 'whitelist.json')
        # Load YARA rules if enabled
        self.yara_rules = None
        if self.config.get('malware', {}).get('enable_yara', False) and YARA_AVAILABLE:
            try:
                self.yara_rules = yara.compile(filepath=self.config['malware']['yara_rules_path'])
            except Exception as e:
                ctx.log.warn(f"[YARA Error] {e}")

    def _check_whitelist_updates(self):
        """Check if whitelist.json has been modified and reload if needed"""
        try:
            if os.path.exists(self.whitelist_path):
                current_modified = os.path.getmtime(self.whitelist_path)
                if current_modified > self.whitelist_last_modified:
                    ctx.log.info(f"[Whitelist] Detected changes in whitelist file, reloading")
                    self.whitelist_last_modified = current_modified
                    # Import the load_whitelist function
                    from main import load_whitelist
                    # Reload the whitelist
                    ctx.whitelist = load_whitelist()
                    ctx.log.info(f"[Whitelist] Reloaded {len(ctx.whitelist)} domains")
        except Exception as e:
            ctx.log.error(f"[Whitelist] Error checking for whitelist updates: {e}")
    
    def is_whitelisted(self, url):
        """Check if a URL's domain is in the whitelist"""
        # Check for whitelist file changes and reload if needed
        self._check_whitelist_updates()
        
        if not hasattr(ctx, 'whitelist') or not ctx.whitelist:
            ctx.log.warn(f"[Whitelist] No whitelist available")
            return False
            
        from urllib.parse import urlparse
        parsed_url = urlparse(url)
        domain = parsed_url.netloc.lower()
        
        # Remove port if present
        if ':' in domain:
            domain = domain.split(':')[0]
        
        # Debug logging
        ctx.log.info(f"[Whitelist Check] Checking if {domain} is in whitelist: {list(ctx.whitelist)}")
        
        # Check for exact domain match
        if domain in ctx.whitelist:
            ctx.log.info(f"[Whitelist Match] Exact match for {domain}")
            return True
        
        # Check www variant (with or without www prefix)
        www_domain = 'www.' + domain if not domain.startswith('www.') else domain[4:]
        if www_domain in ctx.whitelist:
            ctx.log.info(f"[Whitelist Match] WWW variant match for {domain}")
            return True
            
        # Check for subdomain match with wildcard domains
        wildcard_domains = [d for d in ctx.whitelist if d.startswith('*.')]
        for wild_domain in wildcard_domains:
            parent_domain = wild_domain[2:]  # Remove '*.' prefix
            if domain.endswith(parent_domain):
                ctx.log.info(f"[Whitelist Match] Wildcard match {domain} with {wild_domain}")
                return True
                
        # Check for root domain match
        # For example, if a.example.com is checked and example.com is in whitelist
        parts = domain.split('.')
        if len(parts) > 2:
            root_domain = '.'.join(parts[-2:])
            if root_domain in ctx.whitelist:
                ctx.log.info(f"[Whitelist Match] Root domain match {domain} with {root_domain}")
                return True
                
        ctx.log.info(f"[Whitelist] No match for {domain}")
        return False
    
    def response(self, flow):
        # First check if domain is whitelisted
        url = flow.request.pretty_url
        
        # Check if the user has chosen to bypass the malware warning
        if "bypass_malware_warning=true" in url:
            ctx.log.warn(f"[Malware Warning Bypassed] User continued to {url}")
            if DASHBOARD_AVAILABLE:
                dashboard.add_log('WARNING', f"[Malware Warning Bypassed] User continued to {url}")
            # Remove the bypass parameter to prevent infinite loop
            flow.request.url = flow.request.url.replace("?bypass_malware_warning=true", "").replace("&bypass_malware_warning=true", "")
            return
            
        is_whitelisted = self.is_whitelisted(url)
        
        # Enhanced logging for whitelist status
        if is_whitelisted:
            ctx.log.info(f"[Whitelist] ✓ BYPASSING SCAN for {url}")
            if DASHBOARD_AVAILABLE:
                dashboard.add_log('INFO', f"[Whitelist] ✓ BYPASSING SCAN for {url}")
            return
        else:
            ctx.log.info(f"[Whitelist] ✗ NOT whitelisted, scanning {url}")
        
        # Continue with normal scanning if not whitelisted
        is_download_file, download_reason = is_download(flow)
        if is_download_file:
            self.report['downloads_scanned'] += 1
            ctx.log.info(f"[Download detected] {flow.request.pretty_url} Reason: {download_reason}")
            
            # CRITICAL CHANGE: Immediately hold the download with a "Scanning" page
            scanning_html = f"""
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Security Scan in Progress</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f8f8; }}
                    .container {{ max-width: 800px; margin: 0 auto; background-color: white; padding: 30px; border-radius: 5px; 
                                box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }}
                    h1 {{ color: #337ab7; margin-top: 0; }}
                    .spinner {{ border: 16px solid #f3f3f3; border-top: 16px solid #337ab7; border-radius: 50%; width: 80px; height: 80px;
                              animation: spin 2s linear infinite; margin: 20px auto; }}
                    @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>Security Scan in Progress</h1>
                    <div class="spinner"></div>
                    <p>Smart Proxy is scanning the downloaded file for malware.</p>
                    <p>URL: {flow.request.pretty_url}</p>
                    <p>Please wait...</p>
                </div>
            </body>
            </html>
            """
            
            # Hold the response while scanning
            original_response = flow.response.copy()
            flow.response = http.Response.make(
                200,  # Status code
                scanning_html.encode('utf-8'),
                {"Content-Type": "text/html; charset=UTF-8"}
            )
            
            # Now scan the file in a safe way
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                tmp.write(original_response.content)
                tmp_path = tmp.name
            
            try:
                # Scan the file for malware
                found, reason = scan_file(tmp_path)
                # YARA scan (if enabled)
                if self.yara_rules:
                    try:
                        matches = self.yara_rules.match(tmp_path)
                        if matches:
                            found = True
                            reason = f"YARA match: {matches}"
                    except Exception as e:
                        ctx.log.warn(f"[YARA Scan Error] {e}")
                if found:
                    ctx.log.warn(f"[Malware Detected] {flow.request.pretty_url} Reason: {reason}")
                    self.report['malware_found'].append((flow.request.pretty_url, reason))
                    
                    # Create a more robust block page
                    block_html = f"""
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>Security Alert - Malware Blocked</title>
                        <style>
                            body {{ font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f8f8; }}
                            .container {{ max-width: 800px; margin: 0 auto; background-color: white; padding: 30px; border-radius: 5px; 
                                         box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
                            h1 {{ color: #d9534f; margin-top: 0; }}
                            .info {{ border-left: 4px solid #d9534f; padding-left: 15px; margin: 20px 0; }}
                            .details {{ background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-wrap: break-word; }}
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <h1>⚠️ Security Alert: Malware Blocked</h1>
                            <p>Smart Proxy has blocked a file that contains malware or potentially harmful content.</p>
                            
                            <div class="info">
                                <p><strong>URL:</strong> {flow.request.pretty_url}</p>
                                <p><strong>Detection reason:</strong> {reason}</p>
                                <p><strong>Timestamp:</strong> {time.strftime("%Y-%m-%d %H:%M:%S")}</p>
                            </div>
                            
                            <div class="details">
                                <p><strong>Technical details:</strong></p>
                                <p>The requested file was analyzed by Smart Proxy's security scanner and was found to contain
                                suspicious patterns consistent with malware.</p>
                            </div>
                            
                            <p>If you believe this is a false positive, please contact your system administrator.</p>
                            
                            <div style="margin-top: 20px;">
                                <a href="javascript:history.back()" style="display: inline-block; padding: 10px 20px; margin-right: 10px; background-color: #d9534f; color: white; text-decoration: none; border-radius: 4px; font-weight: bold;">Go Back (Recommended)</a>
                                <a href="{flow.request.pretty_url}?bypass_malware_warning=true" style="display: inline-block; padding: 10px 20px; background-color: #f0ad4e; color: white; text-decoration: none; border-radius: 4px; font-weight: bold;">Continue Anyway (Not Recommended)</a>
                            </div>
                        </div>
                    </body>
                    </html>
                    """
                    
                    # Set headers that prevent caching and downloading
                    headers = {
                        "Content-Type": "text/html; charset=UTF-8",
                        "Content-Disposition": "inline",  # Force display in browser
                        "X-Content-Type-Options": "nosniff",  # Prevent MIME sniffing
                        "Cache-Control": "no-store, no-cache, must-revalidate, max-age=0",
                        "Pragma": "no-cache",
                        "Expires": "0",
                        "Content-Length": str(len(block_html.encode('utf-8')))  # Explicit content length
                    }
                    
                    # Replace the response completely
                    flow.response = http.Response.make(
                        403,  # HTTP status code
                        block_html.encode('utf-8'),
                        headers
                    )
                    
                    if DASHBOARD_AVAILABLE:
                        dashboard.add_log('ERROR', f"[Malware Detected] {flow.request.pretty_url} Reason: {reason}")
                else:
                    ctx.log.info(f"[Download Clean] {flow.request.pretty_url}")
                    if DASHBOARD_AVAILABLE:
                        dashboard.add_log('INFO', f"[Download Clean] {flow.request.pretty_url}")
                # TODO: Save scan results to persistent log if enabled in config
            finally:
                os.remove(tmp_path)
            # TODO: Async scan (real async/threaded), threat intelligence lookup, whitelist/blacklist

def load(l):
    if not hasattr(ctx, 'report'):
        ctx.report = {'phishing_urls': [], 'suspicious_js': [], 'unexpected_redirects': [], 'malware_found': [], 'downloads_scanned': 0}
    l.addons.add(MalwareScanner(ctx.report))
